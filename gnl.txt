和訳：get_next_line 要件

繰り返し呼び出し（たとえばループ内で）によって、get_next_line() 関数を使って、指定されたファイルディスクリプタが指すテキストファイルを1行ずつ読み込むことができるようにしてください。

関数は読み込んだ行を返すべきです。

読み込むものが何も残っていない場合、またはエラーが発生した場合は、NULL を返してください。

この関数が、ファイルからの読み込みと、標準入力（stdin）からの読み込みの両方で正しく動作することを確認してください。

戻り値として返される行は、行末の \n（改行文字）を含む必要があります。
　ただし、ファイルの終わりで、最後の行に \n が付いていない場合は含まれません。

get_next_line.h ヘッダファイルには、少なくとも get_next_line() 関数のプロトタイプ（関数宣言）を含める必要があります。

必要な補助関数（ヘルパー関数）はすべて、get_next_line_utils.c ファイルに追加してください。

get_next_line() 関数ではファイルを読み込む必要があるため、コンパイル時に以下のようにオプション -D BUFFER_SIZE=n を追加してください。

これは、read() の際に使用するバッファサイズ（読み込み単位）を定義します。

この BUFFER_SIZE の値は、ピア（同級生）や Moulinette（自動テストシステム）によって変更されてテストされます。

このプロジェクトは、-D BUFFER_SIZE フラグがあってもなくてもコンパイルできるようにしなければなりません。

つまり、自分で適当なデフォルト値（たとえば 32 など）をコード内で定義しておくことも必要です。

⚠ 注意点・動作仕様
get_next_line() の動作は、read() がファイルの終わりに到達する前に、対象ファイルが書き換えられると未定義動作になります。

また、バイナリファイルを読み込む場合も、未定義動作になります。
　ただし、その場合に論理的に対処する方法を自分で実装するのは構いません。

❓ 質問されること（心の準備）
BUFFER_SIZE を 1 にしたら動く？

9999 にしたら？

10000000 にしたら？

→ なぜ動作が変わるのか理解していますか？

✅ パフォーマンスに関する要件
get_next_line() を呼ぶたびに、可能な限り少ないデータを読み取るようにしてください。

改行文字 \n に到達したら、それ以上読まず、すぐにその行を返すこと。

ファイル全体を一気に読み込んでから行ごとに処理するような実装は NG です。

🚫 禁止事項（Forbidden）
このプロジェクトでは、自分の libft を使用してはいけません。

lseek() 関数の使用は禁止です。

グローバル変数の使用は禁止です。
